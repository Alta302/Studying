# 함수와 클로저

## 클로저란?

![img](https://blog.kakaocdn.net/dn/bycgiZ/btqQNquR2nD/zHk4DUmDwqK7vCEesxORI0/img.png)



클로저는 다음과 같이 두가지 종류가 있습니다. Named Closure가 있고, Unnamed Closure가 있는데 다음과 같이 선언해왔던 함수는

```swift
func doSomething() {
	print("changyong")
}
```

Named Closure입니다. 이를 클로저라 부르지 않고, 함수라고 부르는 것입니다.



그리고 다음과 같이 이름을 붙이지 않고 사용하는 함수를

```swift
let closure = { print("changyong") }
```

익명함수, 즉 Unnamed Closure라고 부르는 것입니다. 보통 Closure라고 하면 Unnamed Closure를 말합니다. 따라서 정리하자면



**함수는 Named Closure이고,**

**클로저는 Named Closure & Unnamed Closure 둘 다 포함하지만, 보통 Unnamed Closure를 말합니다.**



## 함수

### 함수 vs 메서드

일반적으로 func이라는 키워드로 생성하는 것은 모두 함수입니다.

```swift
func doSomething() {
	print("changyong")
}
```



메서드는 클래스, 구조체, 열거형 속에 포함되어 있는 "함수"를 말합니다.

만약 func으로 선언한 함수가 클래스, 구조체, 열거형 속에 속해 포함되어 있다면

```swift
class Changyong() {
	func doSomething() {
		print("changyong")
	}
}
```

doSomething을 함수가 아니라 메서드라고 표현합니다.



### 함수의 선언

#### 선언의 기본 형태

```swift
func 함수명(매개변수명: 매개변수 타입, ...) -> 반환 타입 {
  /* 함수 구현부 */
  return 반환값
}

func sum(a: Int, b: Int) -> Int {
  return a + b
}
```



#### 매개변수와 반환값이 없는 함수

```swift
// 반환 값이 없을 경우, 반환 타입(Void)을 생략해 줄 수 있습니다.
func 함수명() {
  /* 함수 구현부 */
  return
}

func bye() { print("bye") }
```



### 매개변수 기본값

매개변수에 기본적으로 전달될 값을 미리 지정할 수 있습니다.

> 기본값을 갖는 매개변수 목록 중에 뒤쪽에 위치하는 것이 좋습니다.

```swift
func 함수명(매개변수명: 매개변수 타입, 매개변수명: 매개변수 타입 = 기본값, ...) -> 반환 타입 {
  /* 함수 구현부 */
  return 반환값
}

func greeting(friend: String, me: String = "changyong") {
  print("Hello \(friend)! I'm \(me)")
}

greeting(friend: "hana") // Hello hana! I'm changyong
greeting(friend: "john", me: "eric") // Hello john! I'm eric
```



### 전달인자 레이블

함수를 호출할 때 함수 사용자의 입장에서 매개변수의 역할을 좀 더 명확하게 표현하고자 할 때 사용합니다.

```swift
func 함수명(전달인자 매개변수명: 매개변수 타입, 전달인자 매개변수명: 매개변수 타입, ...) -> 반환 타입 {
  /* 함수 구현부 */
  return 반환값
}

func greeting(to friend: String, from me: String) {
  print("Hello \(friend)! I'm \(me)")
}

greeting(to: "hana", from: "changyong") // Hello hana! I'm changyong
```



### 가변 매개변수

전달 받을 값의 개수를 알기 어려울 때 사용할 수 있습니다.

> 가변 매개변수는 함수당 하나만 가질 수 있습니다.
>
> 가변 매개변수 바로 뒤에 있는 매개변수는 무조건 전달인자를 가져야 합니다.

```swift
func 함수명(매개변수명: 매개변수 타입, 매개변수명: 매개변수 타입...) -> 반환 타입 {
  /* 함수 구현부 */
  return 반환값
}

func sayHelloToFriends(me: String, friends: String...) {
  return "Hello \(friends)! I'm \(me)!"
}

print(sayHelloToFriends(me: "changyong", friends: "hana", "eric", "wing"))
// Hello ["hana", "eric", "wing"]! I'm changyong!

print(sayHelloToFriends(me: "changyong")
// Hello []! I'm changyong!
```



### 데이터 타입으로서의 함수

스위프트는 함수형 프로그래밍 패러다임을 포함하는 다중 패러다임 언어이므로 스위프트의 함수는 일급 객체입니다. 그래서 함수를 변수, 상수 등에 할당이 가능하고 매개변수를 통해 전달할 수도 있습니다.



#### 함수의 타입 표현

반환 타입을 생략할 수 없습니다.

```swift
(매개변수 타입, 매개변수 타입, ...) -> 반환 타입
```



#### 함수 타입 사용

```swift
var someFunction: (String, String) -> Void = greeting(to:from:)
someFunction("eric", "changyong") // Hello eric! I'm changyong

someFunction = greeting(friend:me:)
someFunction("eric", "changyong") // Hello eric! I'm changyong


// 타입이 다른 함수는 할당할 수 없습니다. - 컴파일 오류 발생
//someFunction = sayHelloToFriends(me: friends:)


func runAnother(function: (String, String) -> Void) {
  function("jenny", "mike")
}

// Hello jenny! I'm mike
runAnother(function: greeting(friend:me:))

// Hello jenny! I'm mike
runAnother(function: someFunction)
```



### 입출력 매개변수

- 파라미터로 전달되는 Value 타입의 값은 복사된 상수값이다.
  - 함수가 실행되는 도중에 호출한 곳에서 변수를 바꿔도, 함수 내부엔 전혀 영향을 주지 않는다.

```swift
func sayHello(name: String) {
  DispatchQueue.main.asyncAfter(deadline: .now() + 3) {
    print("Check #2 \(name)"")
  }
}
 
var name: String = "changyong"
sayHello(name: name)
name = "eric"
print("Check #1 \(name)")

// Check #1 eric
// Check #2 changyong
```



- 파라미터로 전달되는 Reference 타입의 값은 참조된다.
  - Reference Type의 값을 파라미터로 전달할 경우, 참조로 전달된다.

```swift
func changeName(human: Human) {
	human.name = "eric"
}

let changyong = Human.init(name: "changyong", age: 19)
changename(human: changyong)
print(changyong.name) // eric
```



- In-Out Parameters: Value 타입의 값을 참조로 전달하는 방법
  1. 함수 파라미터 선언할 때 inout 키워드 작성하기
  2. 함수를 호출할 때 Argument 앞에 & 붙여주기

```swift
func sayHello(name: inout String) {
  name = "eric"
}

var name: String = "changyong"
sayHello(name: &name)
print(name) // eric
```



### 중첩 함수

```swift
func outer() {
	print("outer")
	
	func inner() {
		print("inner")
	}
  
  inner()
}

outer()
inner() // error
```

```swift
func outer() -> () -> () {
	print("outer")
  
  func inner() {
    print("inner")
  }
  
  return inner
}

let inner = outer()
inner()
```



## 클로저

클로저는 코드의 블럭입니다. 일급 객체로 전달인자, 변수, 상수 등으로 저장, 전달이 가능합니다.

함수는 클로저의 일종으로, `이름이 있는 클로저`라고 생각하면 됩니다.



### 기본 클로저 문법

```swift
{(매개변수 목록) -> 반환 타입 in
	/* 실행 코드 */
}
```



### 클로저의 사용

```swift
let sum: (Int, Int) -> Int = {(a: Int, b: Int) in
  return a + b
}

let sumResult: Int = sum(1, 2)
print(sumResult) // 3
```



### 함수의 전달인자로서의 클로저

클로저는 주로 함수의 전달인자로 많이 사용됩니다. 함수 내부에서 원하는 코드 블럭을 실행할 수 있습니다.

```swift
let add: (Int, Int) -> Int
add = {(a: Int, b: Int) in
  return a + b
}

let substract: (Int, Int) -> Int
substract = {(a: Int, b: Int) in
  return a - b
}

let divide: (Int, Int) -> Int
divide = {(a: Int, b: Int) in
  return a / b
}

func calculate(a: Int, b: Int, method: (Int, Int) -> Int) -> Int {
  return method(a, b)
}

var calculated: Int

calculated = calculate(a: 50, b: 10, method: add)

print(calculated) // 60

calculated = calculate(a: 50, b: 10, method: substract)

print(calculated) // 40

calculated = calculate(a: 50, b: 10, method: divide)

print(calculated) // 5

// 따로 클로저를 상수/변수에 넣어 전달하지 않고, 
// 함수를 호출할 때 클로저를 작성하여 전달할 수도 있습니다.

calculated = calculate(a: 50, b: 10, method: {(left: Int, right: Int) -> Int in
  return left * right
})

print(calculated) // 500
```



### @autoclosure

파라미터로 전달된 일반 구문 & 함수를 클로저로 래핑하는 것

```swift
func doSomething(closure: @autoclosure () -> ()) {
	closure()
}

doSomething(closure: 1 > 2)
```

일반 구문을 클로저처럼 사용할 수 있습니다(클로저로 매핑해서).

@autoclosure를 사용할 경우, 파라미터가 반드시 없어야 합니다.



#### @autoclosure 특징: 지연된 실행

@autoclosure로 작성하면 함수가 실행될 시점에 구문을 클로저로 만들어주기 때문에 함수 내에서 클로저를 실행될 때까지 구문이 실행되지 않습니다.

따라서, @autoclosure는 원래 바로 실행되어야 하는 구문이 지연되어 실행한다는 특징이 있습니다.



### @escaping

Non-escaping Closure - 함수 내부에서 직접 실행하기 위해서만 사용한다. 따라서 파라미터로 받은 클로저를 변수나 상수에 대입할 수 없고, 중첩 함수에서 클로저를 사용할 경우, 중첩 함수를 리턴할 수 없다. 함수의 실행 흐름을 탈출하지 않아, 함수가 종료되기 전에 무조건 실행되어야 한다.

```swift
func doSomething(closure: () -> ()) {
  let f: () -> () = closure
  // error
}

func doSomething(closure: () -> ()) {
  print("function start")
  
  DispatchQueue.main.asyncAfter(deadline: .now() + 10) {
    closure()
  } // error
  
  print("function end")
}

func outer(closure: () -> ()) -> () -> () {
  func inner() {
    closure()
  }
  
  return inner // error
}
```

```swift
func doSomething(closure: @escaping () -> ()) {
  let f: () -> () = closure
}

func doSomething(closure: @escaping () -> ()) {
  print("function start")
  
  DispatchQueue.main.asyncAfter(deadline: .now() + 10) {
    closure()
  
  print("function end")
}
```



non-escaping 클로저는 클로저가 이 함수 내부에서만 쓰이기 때문에 컴파일러가 메모리 관리를 지저분하게 하지 않아도 돼서, 성능이 향상되기 때문에 함수 직전에 무조건 실행되어야 하는 조건이 붙습니다.

non-escaping의 경우 함수가 종료됨과 동시에 클로저도 사용이 끝나지만, escaping의 경우, 함수가 종료되더라도 실제 클로저가 사용되지 않을 때까지 메모리를 추적해야 합니다.



## 다양한 클로저 표현

클로저는 다양한 모습으로 표현될 수 있습니다. 함수의 매개변수 마지막으로 전달되는 클로저는 `후행클로저(trailing closure)`로 함수 밖에 구현할 수 있습니다.

컴파일러가 클로저의 타입을 유추할 수 있는 경우 매개변수, 반환 타입을 생략할 수 있습니다.

반환값이 있는 경우, 암시적으로 클로저의 맨 마지막 줄은 `return` 키워드를 생략하더라도 반환값으로 취급합니다.

전달인자의 이름이 굳이 필요없고, 컴파일러가 타입을 유추할 수 있는 경우 축약된 전달인자 이름(`$0`, `$1`, `$2`…)을 사용할 수 있습니다.



클로저 매개변수를 갖는 함수 `calculate(a:b:method:)`와 결과값을 저장할 변수 `result`를 먼저 선언해둡니다.

```swift
func calculate(a: Int, b: Int, method: (Int, Int) -> Int) -> Int {
  return method(a, b)
}

var result: Int
```



### 후행 클로저

클로저가 함수의 마지막 전달인자라면 마지막 매개변수 이름을 생략한 후 함수 소괄호 외부에 클로저를 구현할 수 있습니다.

```swift
result = calculate(a: 10, b: 10) {(left: Int, right: Int) -> Int in
  return left + right
}

print(result)
```



### 반환타입 생략 및 암시적 반환 표현

`Calculate(a:b:method:)` 함수의 `method` 매개변수는 `Int` 타입을 반환할 것이라는 사실을 컴파일러도 알기 때문에 굳이 클로저에서 반환 타입을 명시해 주지 않아도 됩니다. 대신 `in 키워드는 생략할 수 없습니다.`

클로저가 반환하는 값이 있다면 클로저의 마지막 줄의 결과값은 암시적으로 반환값으로 취급합니다.

```swift
// 후행클로저와 함께 사용할 수도 있습니다
result = calculate(a: 10, b: 10) {
  $0 + $1
}

print(result) // 20

// 간결하게 한 줄로 표현해 줄 수도 있습니다.
result = calculate(a: 10, b: 10) { $0 + $1 }
```



### 단축 인자 이름

클로저의 매개변수 이름이 굳이 불필요하다면 단축 인자이름을 활용할 수 있습니다. 단축 인자이름은 클로저의 매개변수의 순서대로 `$0`, `$1`, `$2`… 처럼 표현합니다.

```swift
result = calculate(a: 10, b: 10, method: {
  return $0 + $1
})
```



## 클로저와 ARC

### 클로저의 값 캡쳐 방식

클로저는 값을 캡쳐할 때 Value/Reference 타입에 관계 없이 Reference Capture합니다.

```swift
func doSomething() {
	var num: Int = 0
	print("num check #1 = \(num)")
	
	let closure = {
		print("num check #3 = \(num)")
	}
	
	num = 20
	print("num check #2 = \(num)")
	closure()
}

// num check #1 = 0
// num check #2 = 20
// num check #3 = 20
```

```swift
func doSomething() {
  var num: Int = 0
  print("num check #1 = \(num)")
    
  let closure = {
    num = 20
    print("num check #3 = \(num)")
  }
    
  closure()
  print("num check #2 = \(num)")
}

// num check #1 = 0
// num check #3 = 20
// num check #2 = 20
```



### 클로저의 캡쳐 리스트

```swift
let closure = {[num,  num2] in
```

클로저의 시작인 { 의 바로 옆에 []를 이용해 캡쳐할 멤버를 나열한다. 이때 in 키워드도 꼭 함께 작성합니다.



#### Value Capture

캡쳐 리스트를 이용하면 Value Type의 경우, Value Capture 하고 싶은 변수를 리스트로 명시해주기 때문에 Value Capture가 가능합니다.

``` swift
func doSomething() {
  var num: Int = 0
  print("num check #1 = \(num)")
    
  let closure = {[num] in // num - Const Value Type
    print("num check #3 = \(num)")
  }
    
  num = 20
  print("num check #2 = \(num)")
  closure()
}

// num check #1 = 0
// num check #2 = 20
// num check #3 = 0
```

``` swift
let closure = {[num, num2] in
	num = 2 // error
}
```

캡쳐 리스트를 작성한다고 해도, Reference Type은 Reference Capture를 합니다.



### 클로저와 ARC

ARC - 인스턴스의 Reference Count를 자동으로 계산하여 메모리를 관리하는 방법

``` swift
class Human {
  var name = ""
  lazy var getName: () -> String = {
    return self.name
  }
    
  init(name: String) {
    self.name = name
  }
 
  deinit {
    print("Human Deinit!")
  }
}

var changyong: Human? = .init(name: "Jeong-Changyong")
print(changyong!.getName()) // Jeong-Changyong

changyong = nil
```



#### 클로저의 강한 순환 참조

``` swift
print(changyong!.getName())
```

getName을 호출하는 순간 getName이란 클로저가 Heap에 할당되며, 이 클로저를 참조할 것입니다.



``` swift
class Human {
  lazy var getName: () -> String = {
    return self.name
  }
}
```

self를 통해 Human이란 인스턴스의 프로퍼티에 접근하고 있는데 클로저는 Reference 값을 캡쳐할 때 기본적으로 "strong"으로 캡쳐를 합니다.

따라서, 이때 Human이란 인스턴스의 Reference Count가 증가해버립니다.

Human 인스턴스는 클로저를 참조하고, 클로저는 Human 인스턴스(의 변수)를 참조하기 때문에 서로가 서로를 참조하고 있어서 둘 다 메모리에서 해제되지 않는 강한 순환 참조가 발생해버린 것입니다.



#### 클로저의 강한 순환 참조 해결법

클로저에서 해결하려면 weak & unowned에 캡쳐 리스트를 이용해야 합니다.

self에 대한 참조를 Closure Capture List를 이용해 weak, unowned로 캡쳐해버리는 것입니다.

``` swift
class Human {
  lazy var getName: () -> String? = {[weak self] in
  	return self?.name
  }
}

class Human {
  lazy var getName: () -> String? = {[unowned self] in
  	return self?.name
  }
}

// Jeong-Changyong
// Human Deinit!
```



weak의 경우 nil을 할당 받을 가능성이 있기에 Optional-Type으로 self에 대한 Optional Binding을 해주어야 하지만,

unowned의 경우엔 Non-Optional Type으로 self에 대한 Optional Binding 없이 사용할 수 있습니다.



### Named Closure의 값 캡쳐 방식

#### 전역 함수

주변의 어떠한 값도 캡쳐하지 않습니다.



#### 중첩 함수

자신을 포함하고 있는 함수의 값을 캡쳐합니다.

```` swift
func outer() {
  var num: Int = 0
  
  func inner() {
    print(num)
  }
}
````

inner 함수는 나를 포함하고 있는 함수 outer의 num이라는 값을 사용하니 캡쳐합니다(Reference Capture).



## 출처

https://yagom.github.io/swift_basic/

https://babbab2.tistory.com/